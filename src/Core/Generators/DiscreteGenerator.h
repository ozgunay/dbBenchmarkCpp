// DiscreteGenerator.h

#ifndef  _DBBENCHMARK_DISCRETEGENERATOR_H_
#define  _DBBENCHMARK_DISCRETEGENERATOR_H_

#include "Generator.h"

#include <atomic>
#include <cassert>
#include <mutex>
#include <vector>

#include "Core/Utility/Utils.h"

namespace dbbenchmark {
namespace generators {
/**
*   \brief An expression that generates a random value in the specified range.
*   \details 
*   \author Ozgun AY
*   \version 1.0
*   \date 21/11/2018
*   \bug None so far
*/
template <typename Value>
class DiscreteGenerator : public Generator<Value> {
public:
  DiscreteGenerator() : sum(0) { }
  void AddValue(Value value, double weight);

  Value Next() override;
  /**
  * Return the previous string generated by the distribution; e.g., returned from the last nextString() call.
  * Calling lastString() should not advance the distribution or have any side effects. If nextString() has not yet
  * been called, lastString() should return something reasonable.
  */
  Value Last() override { return lastValue; }

private:
  std::vector<std::pair<Value, double>> valuesVector;
  double sum;
  std::atomic<Value> lastValue;
  std::mutex mutex;
};

template <typename Value>
inline void DiscreteGenerator<Value>::AddValue(Value value, double weight) {
  if (this->valuesVector.empty()) {
    this->lastValue = value;
  }
  valuesVector.push_back(std::make_pair(value, weight));
  this->sum += weight;
}
/**
* Generate the next string in the distribution.
*/
template <typename Value>
inline Value DiscreteGenerator<Value>::Next() {
  this->mutex.lock();
  double chooser = utility::RandomDouble();
  this->mutex.unlock();
  
  for (auto p = this->valuesVector.cbegin(); p != this->valuesVector.cend(); ++p) {
    if (chooser < p->second / this->sum) {
      return lastValue = p->first;
    }
    chooser -= p->second / this->sum;
  }
  
  assert(false);
  return lastValue;
}

} // namespace generators
} // namespace dbbenchmark

#endif // _DBBENCHMARK_DISCRETEGENERATOR_H_
